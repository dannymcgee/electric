import { ExecutorContext } from "@nx/devkit";
import chalk from "chalk";
import { promises as fs } from "fs";
import fsSync from "fs";
import path from "path";
import * as svg from "svg-parser";
import Options from "./schema";

export { Options };

export default async function (opts: Options, ctx: ExecutorContext) {
	try {
		let svgsPath = path.join(ctx.root, opts.pathToSvgs);
		let outPath = path.join(ctx.root, opts.outputPath);
		let outFile = path.join(outPath, opts.outFileName);

		let files = (await fs.readdir(svgsPath))
			.filter(f => path.extname(f) === ".svg")
			.map(filename => path.join(svgsPath, filename));

		let svgs = (await Promise.all(
				files.map(f => fs.readFile(f, { encoding: "utf-8" }))
			))
			.map((content, idx) => ({
				name: path.basename(files[idx], ".svg"),
				content,
			}));

		let defs = svgs.map(({ name, content }) => {
			let ast = svg.parse(content);
			return {
				name,
				svg: emitNode(ast.children[0]),
			};
		});

		let outContent = [
			"// STOP! This file is automatically generated!",
			"// To update, check this package's `project.json` for the executor to run",
			"",
			"export const ICONS = {",
			...defs.map(({ name, svg }) => `\t${name}: \`${svg}\`,`),
			"};",
			"",
		].join("\n");

		if (!fsSync.existsSync(outPath)) {
			await fs.mkdir(outPath, { recursive: true });
		}
		await fs.writeFile(outFile, outContent);

		return { success: true };
	}
	catch (err) {
		let label = chalk.bold.redBright.inverse(" ERROR ");
		let message = chalk.bold.redBright(err.message);
		console.log(`${label} ${message}`);

		if (err.stack) {
			let stack = err.stack.split("\n").slice(1).join("\n");
			console.log(chalk.red(stack));
		}

		return { success: false };
	}
}

function emitNode(node: svg.Node): string {
	if (node.type !== "element") return "";

	// Opening tag name
	let result = `<${node.tagName} `;

	// Tag attributes
	let props = node.properties ?? {};
	if (node.tagName === "svg") {
		if ("xmlns" in props) {
			result += `xmlns="${props.xmlns}" `;
		}
		if ("viewBox" in props) {
			result += `viewBox="${props.viewBox}" `;
		}
	} else {
		for (let [key, value] of Object.entries(props)) {
			if (
				key === "fill" || key === "style"
				|| key.startsWith("stroke")
				|| key.startsWith("data-")
			) {
				continue;
			}
			result += `${key}="${value}" `;
		}
	}

	// Append children
	if (node.children.length) {
		result += ">";
		result += node.children.filter(isNode).map(emitNode);
		result += `</${node.tagName}>`;
	} else {
		result += "/>";
	}

	return result;
}

function isNode(node: string | svg.Node): node is svg.Node {
	return typeof node !== "string";
}
